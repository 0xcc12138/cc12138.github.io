<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++异常处理分析与还原</title>
      <link href="/c++%E5%BC%82%E5%B8%B8/"/>
      <url>/c++%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="c-异常处理"><a href="#c-异常处理" class="headerlink" title="c++异常处理"></a>c++异常处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch int &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;catch all&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦try内的语句有抛出（throw）异常，就会去搜索对应的catch块执行语句</p><p>值得注意的是，在C++中，当一个异常被抛出时，程序会在找到第一个匹配的catch块之后处理该异常，然后继续执行后续代码。并且，一旦异常被捕获并处理，程序不会再继续搜索其他的catch块来处理同一个异常。</p><h3 id="事件查看器"><a href="#事件查看器" class="headerlink" title="事件查看器"></a>事件查看器</h3><p>介绍下事件查看器这个工具</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1718600434405.png" alt="1718600434405"></p><p>可以用来查看具体是什么异常，但是貌似也可以用调试？？</p><p>这里手动造一个异常</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1718600575669.png" alt="1718600575669"></p><p>打开事件查看器，就可以发现具体的错误码和错误偏移，还有路径</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1718600561100.png" alt="1718600561100"></p><p>值得注意的是，这个偏移量是ROV，相对于ImageBase的偏移</p><h3 id="具体分析C-异常过程"><a href="#具体分析C-异常过程" class="headerlink" title="具体分析C++异常过程"></a>具体分析C++异常过程</h3><p><img src="/c++%E5%BC%82%E5%B8%B8/1719219097725.png" alt="1719219097725"></p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;触发int异常\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span> (<span class="type">float</span> e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;触发了float异常\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个函数有try catch的时候，会在函数头注册一个异常回调函数：</p><p>例如下面的main函数开头：</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1718710227685.png" alt="1718710227685"></p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719061935153.png" alt="1719061935153"></p><p>分析一下这个代码是干啥的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00412640 55                            push    ebp</span><br><span class="line">.text:00412641 8B EC                         mov     ebp, esp</span><br><span class="line">.text:00412643 6A FF                         push    0FFFFFFFFh</span><br><span class="line">.text:00412645 68 00 77 41 00                push    offset __ehhandler$_main</span><br><span class="line">.text:0041264A 64 A1 00 00 00 00             mov     eax, large fs:0</span><br><span class="line">.text:00412650 50                            push    eax</span><br><span class="line">.text:00412651 51                            push    ecx</span><br><span class="line">.text:00412652 81 EC 08 01 00 00             sub     esp, 108h</span><br><span class="line">.text:00412658 53                            push    ebx</span><br><span class="line">.text:00412659 56                            push    esi</span><br><span class="line">.text:0041265A 57                            push    edi</span><br></pre></td></tr></table></figure><p>push    offset  __ ehhandler$ _main，这是一个函数指针，放入栈中</p><p>mov     eax, large fs:0将异常链表存入eax</p><p>后续会有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00412675 8D 45 F4                      lea     eax, [ebp-0Ch]</span><br><span class="line">.text:00412678 64 A3 00 00 00 00             mov     large fs:0, eax</span><br></pre></td></tr></table></figure><p>这个就是将__ehhandler $ _main这个函数置为链表头，原来的作为Next指针存着</p><p>这样就实现了将函数_ _ehhandler$ _main 挂入异常链表</p><p>在含有try的函数结束之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:008527A6 8B 4D F4                      mov     ecx, [ebp+var_C]</span><br><span class="line">.text:008527A9 64 89 0D 00 00 00 00          mov     large fs:0, ecx</span><br></pre></td></tr></table></figure><p>会有一个注销异常链表的操作，这里就是拿出next，然后覆盖掉原来的异常链表，这样，就恢复了原来的异常链表（即注销）</p><p>之前的 push    0FFFFFFFFh，代表try还没开始，也就是说 [ebp-0x4] 位置代表着 trylevel，如果是0xffffffff则代表try块还未开始，如果是0，就代表进入try块</p><p>当结束try块以后，还是会将这个trylevel置为-1</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719062524688.png" alt="1719062524688"></p><p>如果有try嵌套：</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719062762747.png" alt="1719062762747"></p><p>反正也是赋值为非负的一个数</p><p>双击__enhandler__$main</p><p>在调用函数__CxxFrameHandler之前，会传递一个参数，这里就是eax</p><p>其实这就是FuncInfo函数信息表</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1718710265704.png" alt="1718710265704"></p><h4 id="FuncInfo结构"><a href="#FuncInfo结构" class="headerlink" title="FuncInfo结构"></a>FuncInfo结构</h4><p>介绍一下<strong>FuncInfo</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FuncInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    magicNumber dd ;? <span class="comment">//编译器生成的固定数字</span></span><br><span class="line">    maxState dd ? ;<span class="comment">//最大栈展开数的下标值，也就是trylevel最大不能超过maxState,同时也是栈展开最大的次数</span></span><br><span class="line">    pUnwindMap dd ? ;<span class="comment">//指向栈展开函数表的指针，指向UnwindMapEntry表结构</span></span><br><span class="line">    dwTryCount dd ? ;<span class="comment">//一个函数里面的Try块的数量</span></span><br><span class="line">    pTryBlockMap dd ? ;<span class="comment">//Try块的列表，指向TryBlockMapEntry表的结构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//64位程序下会额外多几个成员</span></span><br></pre></td></tr></table></figure><p>其中pUnwindMap和pTryBlockMap分别指向 UnwindMapEntry 和 TryBlockMapEntry 结构</p><p>UnwindMapEntry要配合FuncInfo里面的maxState使用。</p><p>UnwindMapEntry的作用：栈展开的时候需要执行的函数由UnwindMapEntry表记录</p><p>TryBlockMapEntry的作用：这个结构用来判断异常产生在哪一个Try块</p><h4 id="UnwindMapEntry结构"><a href="#UnwindMapEntry结构" class="headerlink" title="UnwindMapEntry结构"></a>UnwindMapEntry结构</h4><p>这个结构记录了需要执行函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UnwindMapEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD toState;<span class="comment">//栈展开数下标值,即Trylevel，到时候看范围就知道</span></span><br><span class="line">    DWORD lpFuncAction;<span class="comment">//展开执行的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈展开存在多个对象，因此以数组的形式记录每个对象的析构信息</p><p>toState 项用来判断结构是否属于处于数组中，lpFuncAction用于记录析构函数所在的地址</p><h4 id="TryBlockMapEntry结构"><a href="#TryBlockMapEntry结构" class="headerlink" title="TryBlockMapEntry结构"></a>TryBlockMapEntry结构</h4><p>在这个结构体中可以知道对应的Try有几个Catch，并且能找到对应的Catch块</p><p>TryBlockMapEntry块成员长这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TryBlockMapEntry</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD tryLow;<span class="comment">//try块的最小状态索引，用于范围检查（trylevel的最小索引）</span></span><br><span class="line">    DWORD tryHigh;  <span class="comment">//try块的最大状态索引，用于范围检查（trylevel的最大索引）</span></span><br><span class="line">    DWORD catchHigh; <span class="comment">//catch块的最高状态索引，用于范围检查（trylevel的上限）</span></span><br><span class="line">    DWORD dwCatchCount;<span class="comment">//catch块的个数</span></span><br><span class="line">    DOWRD pCatchHandlerArray; <span class="comment">//catch块的描述，指向_msRttiDscr表结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TryBlockMapEnrty 表结构用于判断异常产生在哪一个try块，tryLow，tryHigh 项用于检查产生的异常是否来源于try块中</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719197846739.png" alt="1719197846739"></p><p>最左边的TryLow才是真正的trylevel下标，另外一个TryHigh是用来描述范围的</p><h4 id="msRttiDscr-结构"><a href="#msRttiDscr-结构" class="headerlink" title="_msRttiDscr 结构"></a>_msRttiDscr 结构</h4><p>这个结构用于描述try块中的某一个catch块的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_msRttiDscr</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD nFlag;<span class="comment">//用于Catch块的匹配检查</span></span><br><span class="line">    DWORD pType;<span class="comment">//catch块要捕捉的类型，指向TypeDescriptor表结构，如果是零，就代表所有类型，即catch all</span></span><br><span class="line">    DWORD dispCatchObjOffset;  <span class="comment">//用于定位异常对象在当前ESP中的偏移位置</span></span><br><span class="line">    DWORD CatchProc;<span class="comment">//catch块的首地址，可以用来定位catch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说：</p><p>nFlag标记用于检查catch块的类型匹配：</p><p>如果是 1 ：常量2：变量4：未知8:引用</p><p>异常的匹配信息存在pType所指向的结构</p><p>这个结构便是 TypeDescriptor</p><h4 id="TypeDescriptor结构"><a href="#TypeDescriptor结构" class="headerlink" title="TypeDescriptor结构"></a>TypeDescriptor结构</h4><p>这是一个记录 异常类型的结构：具体结构长这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeDescriptor</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD Hash;<span class="comment">//类型名称的Hash数值</span></span><br><span class="line">    DWORD spare;<span class="comment">//保留</span></span><br><span class="line">    DWORD name;<span class="comment">//类型名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些信息之后，就可以通过与抛出异常时的信息进行对比，得到对应的表结构</p><p>再通过_msRttiDscr结构中的CatchProc得到catch块的首地址</p><h3 id="关于throw"><a href="#关于throw" class="headerlink" title="关于throw"></a>关于throw</h3><p>抛出异常的工作 由 throw 抛出，在源代码含有throw的函数体中可以找到__CxxThrowException 这个函数，和之前  _CxxFrameHandler 类似，之前传进去的参数是FuncInfo，这回是  ThrowInfo</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719065341932.png" alt="1719065341932"></p><p>这样可以通过参数，去获取抛出的对象（或者数值）</p><p>另外一个参数就是ThrowInfo</p><p>每一个throw都对应一个ThrowInfo和一个拷贝的对象。里面包含着对应的信息，包括抛出对象的类型（ThrowInfo），里面放了什么（从拷贝对象可知）</p><p>下面是通过ThrowInfo和拷贝对象识别值和类型的过程</p><p><video src="C++逆向/QQ录屏20240623215701~1.mp4"></video></p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719152317760.png" alt="1719152317760"></p><p>但是为什么会有两个RTTI，这是表示CMyException *的类型和void *类型的异常都可以被接收</p><h4 id="ThrowInfo结构"><a href="#ThrowInfo结构" class="headerlink" title="ThrowInfo结构"></a>ThrowInfo结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThrowInfo</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD nFlag;  <span class="comment">//抛出异常类型标记</span></span><br><span class="line">    DWORD pDestructor;<span class="comment">//异常对象的析构函数地址</span></span><br><span class="line">    DWORD pForwardCompat;<span class="comment">//未知</span></span><br><span class="line">    DOWRD pCatchTableTypeArray <span class="comment">//catch块类型表，指向CatchTableTyoeArray表结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nFlag为1的时候，表示抛出常量类型的异常；   2 表示抛出变量类型的异常</p><p>由于在try块中产生的异常被处理后就不会再返回try块了。因此pDestructor的作用就是记录try块里面的异常对象的析构函数地址，当异常处理完成以后调用异常对象的析构函数</p><p>抛出异常所对应的catch块的类型的信息被记录在pCatchTableTypeArray所指向的CatchTableTyoeArray表结构</p><h4 id="CatchTableTypeArray结构"><a href="#CatchTableTypeArray结构" class="headerlink" title="CatchTableTypeArray结构"></a>CatchTableTypeArray结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CatchTableTyoeArray</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD dwCount;<span class="comment">//CatchTableType 数组包含的元素个数</span></span><br><span class="line">    DWORD ppCatchTableType;<span class="comment">//catch块的类型信息，类型为CatchTableType**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ppCatchTableType是一个指向数组的指针，dwCount用来描述数组中元素的个数</p><p>CatchTableType中含有含有处理异常时的所需相关信息</p><h4 id="CatchTableType结构"><a href="#CatchTableType结构" class="headerlink" title="CatchTableType结构"></a>CatchTableType结构</h4><p>CatchTableType中含有含有处理异常时的所需相关信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CatchTableType</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD flag;</span><br><span class="line">    DWORD pTypeInfo;<span class="comment">//指向异常类型的结构,指向TypeDescriptor表结构</span></span><br><span class="line">    DWORD thisDisplacement; <span class="comment">//基类信息</span></span><br><span class="line">    DWORD sizeorOffset; <span class="comment">//类的大小</span></span><br><span class="line">    DWORD pCopyFunction; <span class="comment">//复制构造函数的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag用于标记异常对象属于哪一种类型，例如指针，引用，对象等，标记值所代表的含义为：</p><p>1：简单类型复制2：已被捕获4：有虚表基类复制8：指针和类型引用复制</p><p>当异常类型为对象的时候，由于对象存在基类等相关信息，因此需要将他们也记录下来，thisDisplacement保存了记录基类信息结构的首地址</p><p>PMD结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PMD</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD dwOffsetToThis;<span class="comment">//基类偏移</span></span><br><span class="line">    DWORD dwOffsetToVBase;<span class="comment">//虚基类偏移</span></span><br><span class="line">    DWORD dwOffsetToVbTable; <span class="comment">//基类虚表偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意注意：</p><p>如果Try内有定义对象并且Throw了，那么就要进行析构，Try里面全部对象都要被析构</p><h3 id="还原代码的逻辑："><a href="#还原代码的逻辑：" class="headerlink" title="还原代码的逻辑："></a>还原代码的逻辑：</h3><p><img src="/c++%E5%BC%82%E5%B8%B8/1719198058819.png" alt="1719198058819"></p><p>进入一个函数首先看看有没有调用__CxxFrameHandler，和有没有对fs:[0]这个地址进行操作，这个是有异常的标志。</p><p>然后一顿操作，把FuncInfo解析出来，有maxState个UnwindMapEntry结构，里面有存析构函数（如果存在析构，具体执行顺序看下标），然后还有dwTryCount个TryBlockMapEntry结构，里面存着Catch块的具体地址（_msRttiDscr 结构）</p><p>catch可能不在IDA反编译出来的函数，所以看到try我们需要去自己找对应的catch</p><p>解决了这些结构体，就可以看汇编还原代码了。</p><p>不要把Catch当成一个函数，而是要把它当成代码块</p><p><img src="/c++%E5%BC%82%E5%B8%B8/1719218558733.png" alt="1719218558733"></p><p>看见trylevel为0，就可以匹配到对应的catch块了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/hello/"/>
      <url>/hello/</url>
      
        <content type="html"><![CDATA[<p>占个位🙂</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
